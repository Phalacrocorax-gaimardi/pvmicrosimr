#recompute social variable
ma <- igraph::get.adjacency(social_network)
g <- social_network %>% tidygraph::activate(nodes) %>% dplyr::left_join(a_s,by="ID")
#social network conformity effect
#
#fossil_nodes  <- igraph::V(g)$fuel == "fossil"
#adopter_nodes <- igraph::V(g)$old_solar == 0 & igraph::V(g)$new_solar > 0
adopter_nodes <- igraph::V(g)$new_solar1 > 0 | igraph::V(g)$new_solar2 > 0
a_s$qsp21 <- as.numeric(ma %*% adopter_nodes) #social reinforcement
if(ignore_social) a_s$qsp21 <- 0 #no pvs assumed present in local network
a_s <- a_s %>% dplyr::rowwise() %>% dplyr::mutate(qsp21 = min(qsp21+1,3)) #qsp21 encoding 1,2,3
#agents_out <- a_s
a_s <- a_s %>% dplyr::select(-du,-du_fin,-du_social,-du_theta,-du_tot)
print(paste("time", round(yeartime,1), "PV system adopters",dim(a_s %>% dplyr::filter( (new_solar1 > 0 & old_solar1==0) | (new_solar2 > 0 & old_solar2==0)))[1]))
print(paste("PV system augmentors",dim(a_s %>% dplyr::filter((old_solar1 > 0 & new_solar1 > old_solar1) | (old_solar2 > 0 & new_solar2 > old_solar2) | (old_solar1 > 0 & new_battery > old_battery) || (old_solar2 > 0 & new_battery > old_battery) ))[1]))
return(dplyr::ungroup(a_s))
}
}
#' @param n_unused_cores number of cores left unused in parallel/foreach. Recommended values 2 or 1.
#' @param use_parallel if TRUE uses multiple cores. Use FALSE for diagnostic runs
#' @param ignore_social if TRUE ignore social network effects. Default is FALSE
#'
#' @return a three component list - simulation output, scenario setup, meta-parameters
#' @export
#' @importFrom magrittr %>%
#' @importFrom lubridate %m+%
#' @importFrom foreach %dopar%
#'
runABM <- function(sD, Nrun=1,simulation_end=end_year,resample_society=F,n_unused_cores=2, use_parallel=T,ignore_social=F){
#
year_zero <- 2010
#calibration params:: MOVED TO SYSTDATA WHEN CALIBRATION COMPLETE
p. <- sD %>% dplyr::filter(parameter=="p.") %>% dplyr::pull(value)
lambda. <- sD %>% dplyr::filter(parameter=="lambda.") %>% dplyr::pull(value)
#print(paste("p.=",p.,"lambda.=",lambda.))
seai_elec <- pvmicrosimr::seai_elec
#bi-monthly runs
Nt <- round((simulation_end-year_zero+1)*6)
#annual runs
#Nt <- round((simulation_end-year_zero+1))
agents0 <- agents_init
u_empirical <- empirical_utils
#
if(use_parallel){
number_of_cores <- parallel::detectCores() - n_unused_cores
doParallel::registerDoParallel(number_of_cores)
abm <- foreach::foreach(j = 1:Nrun, .combine=dplyr::bind_rows,.export = c("initialise_agents","update_agents4","make_artificial_society")) %dopar% {
#abm <- foreach::foreach(j = 1:Nrun, .errorhandling = "pass",.export = c("initialise_agents","update_agents4")) %dopar% {
#create a new artificial society for each run
print(paste("Generating network for run",j,"...."))
if(!resample_society) social <- make_artificial_society(pvmicrosimr::pv_society_oo,pvmicrosimr::homophily,5)
if(resample_society){
agent_resample <- sample(1:dim(pvmicrosimr::pv_society_oo)[1],replace=T)
society_new <- society[agent_resample,]
society_new$ID <- 1:dim(pvmicrosimr::pv_society_oo)[1]
social <- make_artificial_society(society_new,pvmicrosimr::homophily,4.5)
}
#randomiise ICEV emissions assignment
#choose segments
agents_in <- initialise_agents(pvmicrosimr::agents_init,year_zero)
#no transactions
agents_in$transaction <- FALSE
agent_ts<- vector("list",Nt)
agent_ts[[1]] <- agents_in #agent parameters with regularized weights
for(t in seq(2,Nt)){
#bi-monthly
yeartime <- year_zero+(t-1)/6
#yeartime <- year_zero + (t-1)
agent_ts[[t]] <- update_agents4(sD,yeartime,agent_ts[[t-1]],social_network=social,ignore_social, empirical_u = u_empirical,p.,lambda.) #static social network, everything else static
#agent_ts[[t]] <- tibble::tibble(t=t)
}
for(t in 1:Nt) agent_ts[[t]]$t <- t
agent_ts <- tibble::as_tibble(data.table::rbindlist(agent_ts,fill=T))
agent_ts$simulation <- j
#add vertex degree
degrees <- tibble::tibble(ID=1:dim(pvmicrosimr::pv_society_oo)[1],degree=igraph::degree(social))
agent_ts <- agent_ts %>% dplyr::inner_join(degrees)
agent_ts
}
meta <- tibble::tibble(parameter=c("Nrun","end_year","beta.","aversion_4.","aversion_5.","lambda.","p."),value=c(Nrun,simulation_end,beta.,aversion_4.,aversion_5.,lambda.,p.))
abm <- abm %>% dplyr::mutate(date=lubridate::ymd("2010-02-01") %m+% months((t-1)*2)) %>% dplyr::arrange(simulation,date) %>% dplyr::select(-t)
return(list("abm"=abm,"scenario"=sD,"system"=meta))
}
#don't use parallel
#comment in next two lines for parallel
if(!use_parallel){
abm <- tibble::tibble()
#number_of_cores <- parallel::detectCores() - n_unused_cores
#doParallel::registerDoParallel(number_of_cores)
#comment out next line for parallel
for(j in 1:Nrun){
#comment in next line for parallel
#abm <- foreach::foreach(j = 1:Nrun, .combine=dplyr::bind_rows,.export = c("initialise_segments","update_agents4")) %dopar% {
#create a new artificial society for each run
print(paste("Generating network for run",j,"...."))
if(!resample_society) social <- make_artificial_society(pv_society_oo,homophily,5)
if(resample_society){
agent_resample <- sample(1:dim(pv_society_oo)[1],replace=T)
society_new <- pv_society_oo[agent_resample,]
society_new$ID <- 1:dim(pv_society_oo)[1]
social <- make_artificial_society(society_new,homophily,5)
}
#randomise ICEV emissions assignment
#choose market segment for each agent
agents_in <- initialise_agents(pvmicrosimr::agents_init,year_zero)
#no transactions
agents_in$transaction <- FALSE
agent_ts <- vector("list",Nt)
agent_ts[[1]] <- agents_in #agent parameters with regularized weights
for(t in seq(2,Nt)){
#
#yeartime <- year_zero+(t-1)
yeartime <- year_zero+(t-1)/6
agent_ts[[t]] <- update_agents4(sD,yeartime,agent_ts[[t-1]],social_network=social,ignore_social,u_empirical,p.,lambda.) #static social network, everything else static
#agent_ts[[t]] <- tibble::tibble(t=t)
}
for(t in 1:Nt) agent_ts[[t]]$t <- t
agent_ts <- tibble::as_tibble(data.table::rbindlist(agent_ts,fill=T))
agent_ts$simulation <- j
#network degree
degrees <- tibble::tibble(ID=1:dim(pv_society_oo)[1],degree=igraph::degree(social))
agent_ts <- agent_ts %>% dplyr::inner_join(degrees)
abm <- dplyr::bind_rows(abm,agent_ts)
#comment in next line for parallel
#agent_ts
}
meta <- tibble::tibble(parameter=c("Nrun","end_year","beta.","aversion_4.","aversion_5.","lambda.","p."),value=c(Nrun,simulation_end,beta.,aversion_4.,aversion_5.,lambda.,p.))
#replace "t" with dates
abm <- abm %>% dplyr::mutate(date=lubridate::ymd("2010-02-01") %m+% months((t-1)*2)) %>% dplyr::arrange(simulation,date) %>% dplyr::select(-t)
return(list("abm"=abm,"scenario"=sD,"system"=meta))
}
}
# beta. <- 0.0247
# beta. <- 0.0247
# aversion_4. <- 0.004
#p. <- 0.008
#p. <- 0.008
#lambda. <- 0.097
#test[[1]] %>% group_by(t,simulation) %>% summarise(bat=sum(new_battery)) %>% ggplot(aes(2010+(t-1),bat,colour=factor(simulation))) + geom_line() + scale_y_continuous(trans="sqrt")
abm
meta <- tibble::tibble(parameter=c("Nrun","end_year","beta.","aversion_4.","aversion_5.","lambda.","p."),value=c(Nrun,simulation_end,beta.,aversion_4.,aversion_5.,lambda.,p.))
a_s
a_s$new_solar1 %>% sum()
b_s
#pv rooftop capacity constrained finacial utilities corresponding to costs in params
#find current (old) values of imports and exports
cer_sys <- b_s %>% dplyr::left_join(dplyr::bind_rows(pvmicrosimr::cer_systems1,pvmicrosimr::cer_systems2,
pvmicrosimr::cer_systems3,pvmicrosimr::cer_systems4))
cer_sys
#cer_sys <- cer_sys %>% dplyr::inner_join(cer_survey %>% dplyr::select(housecode, demand))
#cer_sys1 <- b_s %>% dplyr::left_join(cer_systems1)
#cer_sys2 <- b_s %>% dplyr::left_join(cer_systems2)
#cer_sys3 <- b_s %>% dplyr::left_join(cer_systems3)
#cer_sys4 <- b_s %>% dplyr::left_join(cer_systems4)
#cer_sys <- dplyr::bind_rows(cer_sys1,cer_sys2,cer_sys3,cer_sys4)
cer_sys <- pvmicrosimr::get_shaded_sys(cer_sys)
#cer_sys <- b_s %>% dplyr::left_join(cer_systems)
#new system is an enhancement
#area1,2 is the remaining area for solar
#restruct the search to available areas
cer_sys <- cer_sys %>% dplyr::filter(solar1 <= old_solar1+kWpm2*area1,solar2 <= old_solar2+kWpm2*area2, solar1 >= old_solar1, solar2 >= old_solar2, battery >= old_battery)
cer_sys %>% dim()
#cer_sys_opt <- cer_sys %>% dplyr::group_by(housecode) %>% dplyr::filter(du==max(du))
cer_sys_opt <- cer_sys %>% dplyr::group_by(ID) %>% dplyr::filter(du==max(du))
#calculate utilities: the slow part
cer_sys <- cer_sys %>% dplyr::mutate(du=get_sys_util_0(params,demand,old_imports,old_exports,old_solar1,old_solar2,old_battery,imports,exports,solar1-old_solar1,solar2-old_solar2,battery-old_battery))
cer_sys
cer_sys$du %>% range()
cer_sys$du %>% range(na.r=T)
cer_sys %>% select(housecode,solar1,solar2)
cer_sys %>% dplyr::select(housecode,solar1,solar2,battery,du)
cer_sys %>% dplyr::select(housecode,solar1,solar2,battery,du) %>% pull(du)%>% unique()
cer_sys %>% dplyr::select(housecode,solar1,solar2,battery,du) %>% dplyr::pull(du)%>% unique()
#calculate utilities: the slow part
cer_sys <- cer_sys %>% rowwise() %>% dplyr::mutate(du=get_sys_util_0(params,demand,old_imports,old_exports,old_solar1,old_solar2,old_battery,imports,exports,solar1-old_solar1,solar2-old_solar2,battery-old_battery))
#calculate utilities: the slow part
cer_sys <- cer_sys %>% dplyr::rowwise() %>% dplyr::mutate(du=get_sys_util_0(params,demand,old_imports,old_exports,old_solar1,old_solar2,old_battery,imports,exports,solar1-old_solar1,solar2-old_solar2,battery-old_battery))
cer_sys
cer_sys$du
cer_sys[1000,]
test <- cer_sys[1000,]
get_sys_util_0(params,test$demand)
get_sys_util_0(params,test$demand,test$old_imports,test$old_exports,test$old_solar1,test$old_solar2,test$old_battery,test$imports,test$exports,test$solar1,test$solar2,test$battery)
c(params,test$demand,test$old_imports,test$old_exports,test$old_solar1,test$old_solar2,test$old_battery,test$imports,test$exports,test$solar1,test$solar2,test$battery)
c(test$demand,test$old_imports,test$old_exports,test$old_solar1,test$old_solar2,test$old_battery,test$imports,test$exports,test$solar1,test$solar2,test$battery)
test <- cer_sys[3000,]
c(test$demand,test$old_imports,test$old_exports,test$old_solar1,test$old_solar2,test$old_battery,test$imports,test$exports,test$solar1,test$solar2,test$battery)
get_sys_util_0(params,test$demand,test$old_imports,test$old_exports,test$old_solar1,test$old_solar2,test$old_battery,test$imports,test$exports,test$solar1,test$solar2,test$battery)
params
get_sys_util_0(params,4000,4000,0,0,0,0,2658,6093,9.5,9,0)
demand <- 4000
old_imports <- 4000
old_exports <- 0
old_solar1 <- 0
old_solar2 <- 0
old_battery <- 0
new_imports <- 2658
new_exports <- 6093
d_solar1 <- 9.5
d_solar2 <- 9
d_battery <- 0
include_grant <- T
#npv with cost and technical parameters provided in params
#payments are positive, revenue is negative
d_solar <- d_solar1+d_solar2
old_solar <- old_solar1 + old_solar2
#reduced installation cost model when there is an existing system
#install_cost_pv <- dplyr::case_when((d_solar > 0 & old_solar ==0)~params$pv_install_cost, (d_solar > 0 & old_solar > 0)~params$pv_install_cost/2,
#                             d_solar==0~0)
#assume zero cost to add a battery module
#install_cost_bat <- dplyr::case_when((d_battery > 0 & old_battery == 0)~params$battery_install_cost,(d_battery > 0 & old_battery > 0)~0,
#                              d_battery==0~0)
install_cost_pv <- ifelse(d_solar > 0 & old_solar == 0, params$pv_install_cost, ifelse(d_solar > 0 & old_solar > 0, params$pv_install_cost / 2, 0))
install_cost_bat <- ifelse(d_battery > 0 & old_battery == 0, params$battery_install_cost, ifelse(d_battery > 0 & old_battery > 0, 0, 0))
install_cost <- install_cost_pv + install_cost_bat
#discount_rate <- params$discount_rate
#interest_rate <- params$finance_rate
#term_of_loan <- dplyr::case_when((d_solar==0 & d_battery==0)~0, (d_solar >0 || d_battery>0)~params$term_of_loan)
term_of_loan <- ifelse((d_solar==0 & d_battery==0),0,params$term_of_loan)
#electricity_inflation_rate <- params$e_price_inflation
#fit_inflation_rate <- params$ceg_price_inflation
system_lifetime <- params$system_lifetime
#assume no grant for augmenting an existing system
#grant <- dplyr::case_when((include_grant & old_solar == 0)~seai_grant(params,d_solar,d_battery),
#                          (include_grant & old_solar > 0)~0,
#                          !include_grant~0)
grant <- ifelse(!include_grant,0,ifelse(old_solar > 0,0,seai_grant(params,d_solar,d_battery)))
#first year bill savings
capex <- install_cost + params$pv_cost*d_solar + params$battery_cost*d_battery-grant
#print(paste("capital cost",capital_cost))
amort_payment <- amort(params$interest_rate,term_of_loan)*capex
#exising and new annual bills
first_year_bill_old <- params$e_price*old_imports + params$standing_charge
first_year_bill_new <- params$e_price*new_imports + params$standing_charge
bill_saving <- (params$e_price*new_imports-params$e_price*old_imports)
#existing mss revenue NB tax disregard is hard-wired 200
#first_year_mss_revenue_old0 <- params$ceg*old_exports #add mss model (elec exports)
#first_year_mss_revenue_old <- dplyr::case_when(first_year_mss_revenue_old0 < 200~first_year_mss_revenue_old0,
#                                           first_year_mss_revenue_old0 >= 200~first_year_mss_revenue_old0*(1-params$marginal_tax_rate)+params$marginal_tax_rate*params$ceg_tax_threshold)
first_year_mss_revenue_old <- ifelse(params$ceg*old_exports < params$ceg_tax_threshold, params$ceg*old_exports,
params$ceg*old_exports*(1-params$marginal_tax_rate)+params$ceg_tax_threshold*params$marginal_tax_rate)
#new mss revenue
#first_year_mss_revenue_new0 <- params$ceg*new_exports
#first_year_mss_revenue_new <- dplyr::case_when(first_year_mss_revenue_new0 < 200~first_year_mss_revenue_new0,
#                                           first_year_mss_revenue_new0 >= 200~first_year_mss_revenue_new0*(1-params$marginal_tax_rate)+params$marginal_tax_rate*params$ceg_tax_threshold)
first_year_mss_revenue_new <- ifelse(params$ceg*new_exports < params$ceg_tax_threshold, params$ceg*new_exports,
params$ceg*new_exports*(1-params$marginal_tax_rate)+params$ceg_tax_threshold*params$marginal_tax_rate)
#mss_revenue <- (first_year_mss_revenue_new-first_year_mss_revenue_old)
#geo <- sum(((1 + params$e_price_inflation) / (1 + params$discount_rate))^(1:params$system_lifetime))
npv_loan <- geo_sum(1/(1+params$discount_rate),term_of_loan)*amort_payment
#npv_loan <- sum(1 / (1 + params$discount_rate)^(1:term_of_loan))*amort_payment
npv_bills <- geo_sum((1+params$e_price_inflation)/(1+params$discount_rate),system_lifetime)*first_year_bill_new
#npv_bills <- sum(((1 + params$e_price_inflation) / (1 + params$discount_rate))^(1:params$system_lifetime))*first_year_bill_new
npv_mss <- -geo_sum((1+params$ceg_price_inflation)/(1+params$discount_rate),system_lifetime)*first_year_mss_revenue_new
#npv_mss <- -sum(((1 + params$ceg_price_inflation) / (1 + params$discount_rate))^(1:params$system_lifetime))*first_year_mss_revenue_new
#npv_loan <- ifelse(term_of_loan==0~0, term_of_loan > 0~npv_loan)
npv_loan <- ifelse(term_of_loan==0,0,npv_loan)
npv_noinvest <- geo_sum((1+params$e_price_inflation)/(1+params$discount_rate),system_lifetime)*(first_year_bill_old-first_year_mss_revenue_old)
npv <- npv_loan+npv_bills+npv_mss
npv
npv_noinvest
npv_loan
npv_bills
npv_mss
geo_sum(1/(1+params$discount_rate),term_of_loan)
amort_payment
capex
amort(params$interest_rate,term_of_loan)
params$pv_cost*d_solar
d_solar
params$pv_cost
yeartime
sD %>% filter(str_detect(parameter,"pv"))
sD %>% dplyr::filter(dplyr::str_detect(parameter,"pv"))
sD %>% dplyr::filter(tidyr::str_detect(parameter,"pv"))
sD %>% dplyr::filter(stringr::str_detect(parameter,"pv"))
pv_cost_fun(sD,2031)
pv_cost_fun(sD,2030)
pv_cost_fun(sD,2029)
pv_cost_fun(sD,2022)
pv_cost_fun(sD,2023)
pv_cost_fun(sD,2024)
params$interest_rate
params$discount_rate
d_solar <- d_solar1+d_solar2
old_solar <- old_solar1 + old_solar2
#reduced installation cost model when there is an existing system
#install_cost_pv <- dplyr::case_when((d_solar > 0 & old_solar ==0)~params$pv_install_cost, (d_solar > 0 & old_solar > 0)~params$pv_install_cost/2,
#                             d_solar==0~0)
#assume zero cost to add a battery module
#install_cost_bat <- dplyr::case_when((d_battery > 0 & old_battery == 0)~params$battery_install_cost,(d_battery > 0 & old_battery > 0)~0,
#                              d_battery==0~0)
install_cost_pv <- ifelse(d_solar > 0 & old_solar == 0, params$pv_install_cost, ifelse(d_solar > 0 & old_solar > 0, params$pv_install_cost / 2, 0))
install_cost_bat <- ifelse(d_battery > 0 & old_battery == 0, params$battery_install_cost, ifelse(d_battery > 0 & old_battery > 0, 0, 0))
install_cost <- install_cost_pv + install_cost_bat
term_of_loan <- ifelse((d_solar==0 & d_battery==0),0,params$term_of_loan)
system_lifetime <- params$system_lifetime
#assume no grant for augmenting an existing system
grant <- ifelse(!include_grant,0,ifelse(old_solar > 0,0,seai_grant(params,d_solar,d_battery)))
#first year bill savings
capex <- install_cost + params$pv_cost*d_solar + params$battery_cost*d_battery-grant
#print(paste("capital cost",capital_cost))
amort_payment <- amort(params$discount_rate,term_of_loan)*capex
#exising and new annual bills
first_year_bill_old <- params$e_price*old_imports + params$standing_charge
first_year_bill_new <- params$e_price*new_imports + params$standing_charge
bill_saving <- (params$e_price*new_imports-params$e_price*old_imports)
#existing mss revenue NB tax disregard is hard-wired 200
#first_year_mss_revenue_old0 <- params$ceg*old_exports #add mss model (elec exports)
#first_year_mss_revenue_old <- dplyr::case_when(first_year_mss_revenue_old0 < 200~first_year_mss_revenue_old0,
#                                           first_year_mss_revenue_old0 >= 200~first_year_mss_revenue_old0*(1-params$marginal_tax_rate)+params$marginal_tax_rate*params$ceg_tax_threshold)
first_year_mss_revenue_old <- ifelse(params$ceg*old_exports < params$ceg_tax_threshold, params$ceg*old_exports,
params$ceg*old_exports*(1-params$marginal_tax_rate)+params$ceg_tax_threshold*params$marginal_tax_rate)
#new mss revenue
#first_year_mss_revenue_new0 <- params$ceg*new_exports
#first_year_mss_revenue_new <- dplyr::case_when(first_year_mss_revenue_new0 < 200~first_year_mss_revenue_new0,
#                                           first_year_mss_revenue_new0 >= 200~first_year_mss_revenue_new0*(1-params$marginal_tax_rate)+params$marginal_tax_rate*params$ceg_tax_threshold)
first_year_mss_revenue_new <- ifelse(params$ceg*new_exports < params$ceg_tax_threshold, params$ceg*new_exports,
params$ceg*new_exports*(1-params$marginal_tax_rate)+params$ceg_tax_threshold*params$marginal_tax_rate)
#mss_revenue <- (first_year_mss_revenue_new-first_year_mss_revenue_old)
#geo <- sum(((1 + params$e_price_inflation) / (1 + params$discount_rate))^(1:params$system_lifetime))
npv_loan <- geo_sum(1/(1+params$discount_rate),term_of_loan)*amort_payment
#npv_loan <- sum(1 / (1 + params$discount_rate)^(1:term_of_loan))*amort_payment
npv_bills <- geo_sum((1+params$e_price_inflation)/(1+params$discount_rate),system_lifetime)*first_year_bill_new
#npv_bills <- sum(((1 + params$e_price_inflation) / (1 + params$discount_rate))^(1:params$system_lifetime))*first_year_bill_new
npv_mss <- -geo_sum((1+params$ceg_price_inflation)/(1+params$discount_rate),system_lifetime)*first_year_mss_revenue_new
#npv_mss <- -sum(((1 + params$ceg_price_inflation) / (1 + params$discount_rate))^(1:params$system_lifetime))*first_year_mss_revenue_new
#npv_loan <- ifelse(term_of_loan==0~0, term_of_loan > 0~npv_loan)
npv_loan <- ifelse(term_of_loan==0,0,npv_loan)
npv_noinvest <- geo_sum((1+params$e_price_inflation)/(1+params$discount_rate),system_lifetime)*(first_year_bill_old-first_year_mss_revenue_old)
npv <- npv_loan+npv_bills+npv_mss
npv_noinvest-npv
load_all()
#' @param d_solar1 additional solar capacity on roof1
#' @param d_solar2 additional solar capacity on roof2
#' @param d_battery kWh battery size increment in steps of 2.5 kWh
#' @param include_grant True or False
#' @param customer "domestic" is only option at the moment
#'
#' @return unscaled financial partial utility
#' @export
#'
#' @examples
get_sys_util_0 <- function(params,demand,old_imports,old_exports,old_solar1,old_solar2,old_battery, new_imports,new_exports,d_solar1,d_solar2, d_battery,include_grant=T, customer = "domestic"){
#npv with cost and technical parameters provided in params
#payments are positive, revenue is negative
d_solar <- d_solar1+d_solar2
old_solar <- old_solar1 + old_solar2
#reduced installation cost model when there is an existing system
#install_cost_pv <- dplyr::case_when((d_solar > 0 & old_solar ==0)~params$pv_install_cost, (d_solar > 0 & old_solar > 0)~params$pv_install_cost/2,
#                             d_solar==0~0)
#assume zero cost to add a battery module
#install_cost_bat <- dplyr::case_when((d_battery > 0 & old_battery == 0)~params$battery_install_cost,(d_battery > 0 & old_battery > 0)~0,
#                              d_battery==0~0)
install_cost_pv <- ifelse(d_solar > 0 & old_solar == 0, params$pv_install_cost, ifelse(d_solar > 0 & old_solar > 0, params$pv_install_cost / 2, 0))
install_cost_bat <- ifelse(d_battery > 0 & old_battery == 0, params$battery_install_cost, ifelse(d_battery > 0 & old_battery > 0, 0, 0))
install_cost <- install_cost_pv + install_cost_bat
term_of_loan <- ifelse((d_solar==0 & d_battery==0),0,params$term_of_loan)
system_lifetime <- params$system_lifetime
#assume no grant for augmenting an existing system
grant <- ifelse(!include_grant,0,ifelse(old_solar > 0,0,seai_grant(params,d_solar,d_battery)))
#first year bill savings
capex <- install_cost + params$pv_cost*d_solar + params$battery_cost*d_battery-grant
#print(paste("capital cost",capital_cost))
amort_payment <- amort(params$discount_rate,term_of_loan)*capex
#exising and new annual bills
first_year_bill_old <- params$e_price*old_imports + params$standing_charge
first_year_bill_new <- params$e_price*new_imports + params$standing_charge
bill_saving <- (params$e_price*new_imports-params$e_price*old_imports)
#existing mss revenue NB tax disregard is hard-wired 200
#first_year_mss_revenue_old0 <- params$ceg*old_exports #add mss model (elec exports)
#first_year_mss_revenue_old <- dplyr::case_when(first_year_mss_revenue_old0 < 200~first_year_mss_revenue_old0,
#                                           first_year_mss_revenue_old0 >= 200~first_year_mss_revenue_old0*(1-params$marginal_tax_rate)+params$marginal_tax_rate*params$ceg_tax_threshold)
first_year_mss_revenue_old <- ifelse(params$ceg*old_exports < params$ceg_tax_threshold, params$ceg*old_exports,
params$ceg*old_exports*(1-params$marginal_tax_rate)+params$ceg_tax_threshold*params$marginal_tax_rate)
#new mss revenue
#first_year_mss_revenue_new0 <- params$ceg*new_exports
#first_year_mss_revenue_new <- dplyr::case_when(first_year_mss_revenue_new0 < 200~first_year_mss_revenue_new0,
#                                           first_year_mss_revenue_new0 >= 200~first_year_mss_revenue_new0*(1-params$marginal_tax_rate)+params$marginal_tax_rate*params$ceg_tax_threshold)
first_year_mss_revenue_new <- ifelse(params$ceg*new_exports < params$ceg_tax_threshold, params$ceg*new_exports,
params$ceg*new_exports*(1-params$marginal_tax_rate)+params$ceg_tax_threshold*params$marginal_tax_rate)
#mss_revenue <- (first_year_mss_revenue_new-first_year_mss_revenue_old)
#geo <- sum(((1 + params$e_price_inflation) / (1 + params$discount_rate))^(1:params$system_lifetime))
npv_loan <- geo_sum(1/(1+params$discount_rate),term_of_loan)*amort_payment
#npv_loan <- sum(1 / (1 + params$discount_rate)^(1:term_of_loan))*amort_payment
npv_bills <- geo_sum((1+params$e_price_inflation)/(1+params$discount_rate),system_lifetime)*first_year_bill_new
#npv_bills <- sum(((1 + params$e_price_inflation) / (1 + params$discount_rate))^(1:params$system_lifetime))*first_year_bill_new
npv_mss <- -geo_sum((1+params$ceg_price_inflation)/(1+params$discount_rate),system_lifetime)*first_year_mss_revenue_new
#npv_mss <- -sum(((1 + params$ceg_price_inflation) / (1 + params$discount_rate))^(1:params$system_lifetime))*first_year_mss_revenue_new
#npv_loan <- ifelse(term_of_loan==0~0, term_of_loan > 0~npv_loan)
npv_loan <- ifelse(term_of_loan==0,0,npv_loan)
npv_noinvest <- geo_sum((1+params$e_price_inflation)/(1+params$discount_rate),system_lifetime)*(first_year_bill_old-first_year_mss_revenue_old)
npv <- npv_loan+npv_bills+npv_mss
#positive is good
return((npv_noinvest-npv)/npv_noinvest)
}
load_all()
rm(list = c("get_sys_util_0", "runABM", "update_agents4"))
load_all()
get_sys_util_0(params,test$demand,test$old_imports,test$old_exports,test$old_solar1,test$old_solar2,test$old_battery,test$imports,test$exports,test$solar1,test$solar2,test$battery)
update_agents4(sD,2030,agents_in,social)
test <- update_agents4(sD,2030,agents_in,social)
test$new_solar1 %>% sum()
#pv rooftop capacity constrained finacial utilities corresponding to costs in params
#find current (old) values of imports and exports
cer_sys <- b_s %>% dplyr::left_join(dplyr::bind_rows(pvmicrosimr::cer_systems1,pvmicrosimr::cer_systems2,
pvmicrosimr::cer_systems3,pvmicrosimr::cer_systems4))
#cer_sys <- cer_sys %>% dplyr::inner_join(cer_survey %>% dplyr::select(housecode, demand))
#cer_sys1 <- b_s %>% dplyr::left_join(cer_systems1)
#cer_sys2 <- b_s %>% dplyr::left_join(cer_systems2)
#cer_sys3 <- b_s %>% dplyr::left_join(cer_systems3)
#cer_sys4 <- b_s %>% dplyr::left_join(cer_systems4)
#cer_sys <- dplyr::bind_rows(cer_sys1,cer_sys2,cer_sys3,cer_sys4)
cer_sys <- pvmicrosimr::get_shaded_sys(cer_sys)
#cer_sys <- b_s %>% dplyr::left_join(cer_systems)
#new system is an enhancement
#area1,2 is the remaining area for solar
#restruct the search to available areas
cer_sys <- cer_sys %>% dplyr::filter(solar1 <= old_solar1+kWpm2*area1,solar2 <= old_solar2+kWpm2*area2, solar1 >= old_solar1, solar2 >= old_solar2, battery >= old_battery)
#calculate utilities: the slow part
cer_sys <- cer_sys %>% dplyr::rowwise() %>% dplyr::mutate(du=get_sys_util_0(params,demand,old_imports,old_exports,old_solar1,old_solar2,old_battery,imports,exports,solar1-old_solar1,solar2-old_solar2,battery-old_battery))
cer_sys
cer_sys$du
cer_sys$du %>% range()
params$e_price
params$ceg
params$pv_cost
cer_sys[2000,]
cer_sys[2000,] %>% select(housecode,demand)
cer_sys[2000,] %>% dplyr::select(housecode,demand)
cer_sys[000,] %>% dplyr::select(housecode,demand)
cer_sys[3000,] %>% dplyr::select(housecode,demand)
cer_sys[3000,] %>% ungroup() %% dplyr::select(housecode,demand)
cer_sys[3000,] %>% ungroup() %>% dplyr::select(housecode,demand)
cer_sys[3000,] %>% dplyr::ungroup() %>% dplyr::select(housecode,demand)
cer_sys[3000,] %>% dplyr::ungroup() %>% dplyr::select(housecode,demand,old_solar1,old_solar2,old_battery,new_imports,new_exports,solar1,solar2,battery)
cer_sys[3000,] %>% dplyr::ungroup() %>% dplyr::select(housecode,demand,old_solar1,old_solar2,old_battery,new_imports,new_exports,solar1,solar2,battery)
cer_sys[3000,] %>% dplyr::select(housecode,demand,old_solar1,old_solar2,old_battery,new_imports,new_exports,solar1,solar2,battery)
cer_sys[3000,]
cer_sys[3000,] %>% dplyr::select(housecode,demand,old_imports,old_exports,old_solar1,old_solar2,old_battery,new_imports,new_exports,solar1,solar2,battery)
cer_sys[3000,] %>% dplyr::select(housecode,demand,old_imports,old_exports,old_solar1,old_solar2)
cer_sys[3000,] %>% dplyr::select(housecode,demand,old_imports,old_exports,old_solar1,old_solar2,old_battery,new_imports,new_exports)
cer_sys[3000,] %>% dplyr::select(housecode,demand,old_imports,old_exports,old_solar1,old_solar2,old_battery,imports,exports,solar1,solar2,battery)
cer_sys[3000,] %>% dplyr::select(housecode,demand,old_imports,old_exports,old_solar1,old_solar2,old_battery,imports,exports,solar1,solar2,battery,du)
#scenario_wem <- readxl::read_xlsx("~/Policy/AgentBasedModels/solarPV/scenario_parameters.xlsx",sheet="scenario_WEM")
sD <- readxl::read_xlsx("~/Policy/AgentBasedModels/solarPV/scenario_parameters.xlsx",sheet="scenario_G")
params <- scenario_params_df(sD,2030)
params$e_price
params <- scenario_params_df(sD,2031)
params$e_price
rooftop_solar_lcoe(params,0.1,4)
test <- update_agents4(sD,2030,agents_in,social)
test$solar1 %>% sum()
test$new_solar1 %>% sum()
#pv rooftop capacity constrained finacial utilities corresponding to costs in params
#find current (old) values of imports and exports
cer_sys <- b_s %>% dplyr::left_join(dplyr::bind_rows(pvmicrosimr::cer_systems1,pvmicrosimr::cer_systems2,
pvmicrosimr::cer_systems3,pvmicrosimr::cer_systems4))
#cer_sys <- cer_sys %>% dplyr::inner_join(cer_survey %>% dplyr::select(housecode, demand))
#cer_sys1 <- b_s %>% dplyr::left_join(cer_systems1)
#cer_sys2 <- b_s %>% dplyr::left_join(cer_systems2)
#cer_sys3 <- b_s %>% dplyr::left_join(cer_systems3)
#cer_sys4 <- b_s %>% dplyr::left_join(cer_systems4)
#cer_sys <- dplyr::bind_rows(cer_sys1,cer_sys2,cer_sys3,cer_sys4)
cer_sys <- pvmicrosimr::get_shaded_sys(cer_sys)
#cer_sys <- b_s %>% dplyr::left_join(cer_systems)
#new system is an enhancement
#area1,2 is the remaining area for solar
#restruct the search to available areas
cer_sys <- cer_sys %>% dplyr::filter(solar1 <= old_solar1+kWpm2*area1,solar2 <= old_solar2+kWpm2*area2, solar1 >= old_solar1, solar2 >= old_solar2, battery >= old_battery)
#calculate utilities: the slow part
cer_sys <- cer_sys %>% dplyr::rowwise() %>% dplyr::mutate(du=get_sys_util_0(params,demand,old_imports,old_exports,old_solar1,old_solar2,old_battery,imports,exports,solar1-old_solar1,solar2-old_solar2,battery-old_battery))
#cer_sys %>% dplyr::mutate(du=get_sys_util_0(params,demand,old_imports,old_exports,old_solar1,old_solar2,old_battery,imports,exports,solar1-old_solar1,solar2-old_solar2,battery-old_battery)) %>% system.time()
#use data.table?
#cer_sys <- data.table::data.table(cer_sys)
#cer_sys[][,du:=get_sys_util_0(params,demand,old_imports,old_exports,old_solar1,old_solar2,old_battery,imports,exports,solar1-old_solar1,solar2-old_solar2,battery-old_battery)] %>% system.time()
#optimal
if(dim(cer_sys)[1]==0) return(cer_sys)
cer_sys %>% dplyr::rowwise() %>% dplyr::mutate(du=get_sys_util_0(params,demand,old_imports,old_exports,old_solar1,old_solar2,old_battery,imports,exports,solar1-old_solar1,solar2-old_solar2,battery-old_battery)) %>% system.time()
cer_sys %>% dplyr::mutate(du=get_sys_util_0(params,demand,old_imports,old_exports,old_solar1,old_solar2,old_battery,imports,exports,solar1-old_solar1,solar2-old_solar2,battery-old_battery)) %>% system.time()
#calculate utilities: the slow part
cer_sys <- cer_sys %>% dplyr::rowwise() %>% dplyr::mutate(du=get_sys_util_0(params,demand,old_imports,old_exports,old_solar1,old_solar2,old_battery,imports,exports,solar1-old_solar1,solar2-old_solar2,battery-old_battery))
cer_sys
cer_sys[2000,]$du
#calculate utilities: the slow part
cer_sys <- cer_sys %>% dplyr::mutate(du=get_sys_util_0(params,demand,old_imports,old_exports,old_solar1,old_solar2,old_battery,imports,exports,solar1-old_solar1,solar2-old_solar2,battery-old_battery))
cer_sys[2000,]$du
load_all()
document()
check()
install()
8792*1000/(1.15e+6)
8792*1000/(1.86e+6)
8350*1000/(1.86e+6)
seai_elec <- readr::read_csv("~/Policy/AgentBasedModels/solarPV/IrelandData/electricity_household_demand_price_SEAI.csv")
seai_elec
library(devtools)
use_data(seai_elec,overwrite = T)
seai_elec
seai_elec1 <- pvmicrosimr::seai_elec %>% dplyr::filter(year >=2008) #add more costs here if known
library(tidyverse)
seai_elec1 <- pvmicrosimr::seai_elec %>% dplyr::filter(year >=2008) #add more costs here if known
seai_elec
load_all()
runABM(scenario_wem,1,simulation_end = 2024)
dim(seai_elec)
document()
help(seai_elec)
document()
help(seai_elec)
check()
install()
